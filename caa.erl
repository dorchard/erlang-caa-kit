-module(caa).
-export([main/3]).

-type func() :: string().
    % func() is the function name, for
    % which the user wants to extract the CAA
    % model. func() is represented as:
    % "<function_name>/<function_Arity>"
    % e.g.,
    % foo(A, B) will be "foo/2"

-type file() :: string().
    % file() is the name of the file which
    % contains the function().

-type location() :: string().
    % location where the user wants the CAA.pdf,
    % graph.dot and automata.txt files to be
    % created.

-type error() :: {error, parse_file:openError()}
               | {error, parse_file:errorInfo()}
               | {error, parse_file:line()}
               | string().
    % error() represent errors encounter either while
    % parsing the file of given file() to form() or
    % while finding the given func() inside the form().

-type delta() :: [type:transition()].
    % delta() contains list of transitions
    % which represents the transition
    % relations.


-type form() :: erl_parse:abstract_form().
    % form() is the erl_parse:abstract_form()
    % of the file of given file().

-type method_Form() :: method_Form:caa_methodForm().

-type methodState_Map() :: map().
    % methodState_Map() is a map, where the key is
    %   method_Form:methodTerm()
    % and the value is the stating state of this given
    % method_Form:methodTerm() method in the delta().
    %
    % It is used for dectecting recursion.

-type last_Transition_State() :: type:state().
    % last_Transition_State() represents the transtion
    % state in the last taransition of delta().

-type pre_assumedState() :: type:state().
    % pre_assumedState() represents the pre_assumed next state after a
    % receive or case or many clauses.

-type transition_States() :: [type:state()].
    % transition_States() is list containing all the transition states
    % happened in the delta() so far.

-type max_StateMethod() :: type:state().
    % max_StateMethod() represents the max transitino state in the delta().

-type caa_Info() :: {type:caa(), last_Transition_State(), max_StateMethod(), transition_States(),
                     noRecursion()}.
    % caa_data() is a tuple containing information about the caa().

-type noRecursion() :: boolean().
    % The noRecursion() represent if there was "no recursion".
    % i.e., false means there was recursion and true means
    % there was no recursion

-type clauses() :: method_Form:caa_clauseForm().
    % clauses in AST form generated by method_Form:getMethod()

-type many_clauses() :: boolean().
    % many_clauses() is for to check if there are more than
    % one clause inside a method, when many clauses brings
    % unlabelled transitions

-type is_Nth_clause() :: boolean().
    % is_Nth_clause() is for to know while traversing over the
    % clauses of a method we are at clause N (where N > 1). It main
    % application is in distinguishing the first clause from the rest
    % when there are multiple clauses inside a method

-type lastClause_max_State() :: type:state().
   % lastClause_max_State() tells the max transition state of the last
   % clause when there are multiple clauses.

-type parent_Last_Transition_State() :: type:state().
   % similar to last_Transition_State(), but parent_Last_Transition_State() tells
   % the last transition state of the parent method as this method (child-method)
   % can be a call from inside of another method (parent-method)

-type length_Clauses() :: integer().
   % length_Clauses() tells the number of clauses a method have. It's main
   % application is in figuring out if all the clauses inside a method had recursion.

-type expressions() :: method_Form:caa_clauseBody().

-type delta_Info() :: {delta(), last_Transition_State(), transition_States(), noRecursion()}.
    % delta_Info() is a tuple which contains the delta() for the given expressions() and some
    % additional information about the delta().

-type receive_clauses() :: method_Form:caa_clauseForm().

-type last_receive_max_state() :: type:state().
    % last_receive_max_state() represent the max transition state of the last receive clause

-type transition_from() :: type:state().
    % transition_from() represents start state for the given label().

-type max_State() :: type:state().
    % represent the max state in the delta(). It's mainly used for computing the next transition
    % state.

-type recursionToMethod_State() :: type:state().
    % recursionToMethod_State() reprent the starting state of the recursive method.

-type empty_Xs() :: boolean().
    % empty_Xs() tells if expressions() is empty or not after the current send expression.
    % It is used detecting what should be the transition state or pre-assumed state


-type exist_PreAssumedState() :: boolean().
    % exist_PreAssumedState() tells if the is pre-assumed state set or not.
    % i.e. -1 means it's not set and any arbitrary number > 0 means it has been set
    % by a parent method or a receive or clause expression.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec main(file(), func(), location()) -> error() | type:caa().
    % main/3 takes file(), function() and location()
    % as inputs and either return an error if the given
    % file() or function() do not exist or return a CAA
    % model, also creates automata.txt, graph.dot and
    % CAA.pdf in the given location() and opens the CAA.pdf.
    %
    % NOTE: automata.txt contains the CAA model, graph.dot
    % contains the CAA model in dot (graphviz) representation
    % and CAA.pdf represents the visual graphical representation
    % of the CAA model.


main(Filename, Function, Location) ->
  [Method, Arity] = string:split(Function, "/"),
  % gets the file of given file()
  % and parse it to form()
  case parseToForm(Filename) of
   % if an error occured during parsing
   {error, Error} -> Error;
   % -type Form :: form().
   Form ->
      % gets the method_Form() from the form()
      case method_Form:getMethod(Form, % form()
             list_to_atom(Method), % method_Form:method()
             list_to_integer(Arity), % arity()
             Form, [Method ++ "->" ++ Arity]) of % form(), method_Form:parents()

       % if the given func() not found inside the form()
       error -> "No such method found";

       % -type  Method_Form :: method_Form:()
       Method_Form ->
          % extracts the CAA model from the method_Form().
          % -type CAA :: caa()
          {CAA,  _, _, _} = caa(Method_Form, % method_Form()
                              #{}, % #{} is methodState_Map()
                              0, % last_Transition_State()
                              -1, %  pre_assumedState()
                              [0], % transition_States()
                              []), % delta()

          % creates the automata.txt file in the given location()
          Automata = lists:flatten(io_lib:format("~sautomata.txt", [Location])),
          file:write_file(Automata, lists:flatten(io_lib:format("~p", [CAA]))),
          % creates the visual representation of the CAA model
          visualisation:graph(CAA, % caa()
                         Location), % location()
           % standard ouputs the CAA model
          CAA
    end
end.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-spec parseToForm(file()) -> error() | form().
    % parseToForm/1 takes the filename and return
    % error() or form() according to if there was any
    % error while parsing the file of given filename.

parseToForm(Filename) ->
    case epp:parse_file(Filename, Filename) of
     % if there was any error
     {error, OpenError} -> {error, {error, OpenError}};
     {ok, {error, ErrorInfo}} -> {error, {{error, ErrorInfo}}};
     {ok, {eof, Line}} -> {error, {eof, Line}};

     % parsing was succesful
     {ok, Form} -> Form
end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec caa(method_Form(), methodState_Map(), last_Transition_State(), pre_assumedState(),
          transition_States(), delta()) -> caa_Info().
    % caa/6 takes the method-form of the given file, map of type methodState_Map(), the
    % last transition state so far, the pre-assumed state and list of transition states
    % and delta; and return a tuple which contain the CAA model, last transition state of the CAA
    % model, list of all the transition states so far, boolean telling "no recursion" or
    % not.

caa({_, _, _, _, Clauses, Method_Term}, MethodState_Map, Last_Transition_State, Pre_assumedState,
  Transition_States, Delta) ->
    clause(Clauses, % clauses inside the method_form(): clauses()
      length(Clauses) > 1, % many_clauses()
      false, % false because we are going to start from the very 1st clause: is_Nth_clause()
      maps:merge(MethodState_Map, #{Method_Term => Last_Transition_State}),% methodState_Map()
      0, % lastClause_max_State()
      Delta, % delta()
      Last_Transition_State, % the last transition so far: parent_Last_Transition_State()
      Pre_assumedState, % pre_assumedState() of the parent method because this can a be child method
      Transition_States, % transition_States()
      length(Clauses)). % to check later if all the clauses had recusrion: length_Clauses()

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec clause(clauses(), many_clauses(), is_Nth_clause(), methodState_Map(), lastClause_max_State(),
        delta(), parent_Last_Transition_State(), pre_assumedState(), transition_States(),
        length_Clauses()) -> caa_Info().
    % clause/11 deals with the clauses of a method i.e, traversing via the clauses
    % and assigning them their start state and replacing the last transition state
    % (if no recursion) of a clause delta with pre_assumedState(). And it passes
    % the clause body of a particular clause to the expressions/6 which deals with the
    % delta of a clause. After traversing via all the clauses of a method, clause/13
    % return a tuple which contains the CAA model of that method and some addition
    % information regarding the CAA model.


% After traversing via all the clauses,
% all the clauses had recursion. i.e.,
% length_Clauses() == 0  (11th parameter of this method)
clause([], _, _, _, _, Delta, Parent_Last_Transition_State, _, Transition_States, 0) ->
    {{Parent_Last_Transition_State, Delta}, % the CAA model
     -1, % -1 because no point of clause-last transition state
     Transition_States,
     false}; % false because of there was recursion, remember this element represent "no-recursion"


%%%%% end of clause %%%%%


% After traversing via all the clauses,
% not all the clauses or no clauses had recursion in them
clause([], _, _, _, _, Delta, Parent_Last_Transition_State,
  Pre_assumedState, Transition_States, _) ->
    % we pass the Pre_assumedState as the last transition state because
    % all the clauses which didn't had recursion had this state as their last state
    {{Parent_Last_Transition_State, Delta},
     Pre_assumedState,
     Transition_States,
     true};


%%%%% end of clause %%%%%


% when there is only one clause in the method
clause([{_,_,_,_,Clause_Body}], false, false, MethodState_Map, _, Delta,
  Parent_Last_Transition_State, Pre_assumedState, Transition_States, Length_Clauses) ->
    % passes the Clause_Body to expressions/6 and gets
    % this clause Delat with other important information about
    % the delta
    {Clause_Delta, Clause_Last_Transition_State, Clause_Transition_States, NoRecursion} =
        expressions(Clause_Body, % expressions()
         MethodState_Map, % methodState_Map()
         Delta, % delta()
         Parent_Last_Transition_State, % last_Transition_State()
         Pre_assumedState, % pre_assumedState()
         Transition_States), % transition_States()

    % go to the base case with the delta
    % Here -1 represent the paramaters we don't
    % care about in the base cases.
    % And we are passing,
    % Clause_Last_Transition_State as clausesPre_assumedState()
    % because this is the last transition state and there is no
    % clause left as there was only 1 clause in this method
    % Note:  noRecursion/2 reduce length_Clauses() by 1 if there was
    % recurion inside this clause
    clause([], % clauses(), [] because there was only one clause in this method
     -1, -1, %  many_clauses() and is_Nth_clause()
     MethodState_Map, % methodState_Map()
     -1, % lastClause_max_State()
     Clause_Delta, % delta(),
     Parent_Last_Transition_State, % parent_Last_Transition_State()
     Clause_Last_Transition_State, % pre_assumedState()
     Clause_Transition_States, %  transition_States()
     noRecursion(NoRecursion, Length_Clauses)); % length_Clauses(),



%%%%% end of clause %%%%%


% when there are many clauses in this method and
% we are at the very first clause i.e,
% many_clauses() == true and
% is_Nth_clause() == false (where N > 1)
%  (parameter 2 and 3 respectively)
clause([{_,_,_,_,Clause_Body}|Xs], true, false, MethodState_Map, _, Delta,
  Parent_Last_Transition_State, ThePre_assumedState, Transition_States, Length_Clauses) ->
    % gets the so far Max transition/CAA state as this method can be a child-method
    % i.e., call from a parent method
    MAX_CAA_State = lists:max(Transition_States),
    % get the "right" pre-assumed State, like for the case this is the given method
    {Pre_assumedState,  Pre_Transition_States, Pre_MAX_CAA_State}=
      getPre_assumedState(true, % empty_Xs() : it's need to be true for this case to work
        ThePre_assumedState =/= -1, % exist_PreAssuedState()
        ThePre_assumedState, % pre_assumedState()
        MAX_CAA_State+1, % pre_assumedState()
        Transition_States),
    % delta_info()
    % get the delta for this clause with some addition information about the delta
    {Clause_Delta, Clause_Last_Transition_State, Clause_Transition_States, NoRecursion} =
    % we are passing "MAX_CAA_State+2" in place of last_Transition_State() because
    % "MAX_CAA_State+2" is the unlabelled transition for this clause and that why
    % we are adding it to the Tranition_States list transition_States()
      expressions(Clause_Body, % expressions()
        MethodState_Map, % methodState_Map()
        % delta() : adding unlabelled transition to the delta
        addTransition(Delta, % delta()
          Parent_Last_Transition_State, % transition_from()
          Pre_MAX_CAA_State+1, % pre-assumed state
          unlabelled),
        Pre_MAX_CAA_State+2, % last_Transition_State()
        Pre_assumedState, % pre_assumedState()
        [Pre_MAX_CAA_State+2] ++ Pre_Transition_States), % transition_States()

    % check if the last transition is only a unlabelled transition
    {Check_Delta, Check_Transition_States} =
      check_UnlabelRecv(unlabelled,
        lists:reverse(Clause_Delta),
        Pre_assumedState,
        NoRecursion,
        Clause_Last_Transition_State,
        Clause_Transition_States),

    % traverse over other clauses
    % is_Nth_clause() is true because next clause is going to be the 2nd clause
    clause(Xs, % clauses()
      true, % many_clauses()
      true, % is_Nth_clause()
      MethodState_Map, % methodState_Map()
      lists:max(Check_Transition_States), % lastClause_max_State()
      lists:reverse(Check_Delta), % delta()
      Parent_Last_Transition_State, % parent_Last_Transition_State()
      Pre_assumedState, % pre_assumedState()
      Check_Transition_States, % transition_States()
      noRecursion(NoRecursion, Length_Clauses)); % length_Clauses()


%%%%% end of clause %%%%%


% when we are at the Nth clause where N > 1 i.e, is_Nth_clause() == true
clause([{_,_,_,_,Clause_Body}|Xs], true, true, MethodState_Map, Max_State_lastClause,
   Delta, Parent_Last_Transition_State, Pre_assumedState,
  Transition_States, Length_Clauses) ->
    % delta_info()
    % get the delta for this clause with some addition information about the delta
    {Clause_Delta, Clause_Last_Transition_State, Clause_Transition_States, NoRecursion} =
    % we are passing "Max_State_lastClause+1" in place of last_Transition_State() because
    % "Max_State_lastClause+1" is the unlabelled transition for this clause and that why
    % we are adding it to the Tranition_States list transition_States()
        expressions(Clause_Body, % expressions()
          MethodState_Map, % methodState_Map()
          % delta() : add unlabelled transition
          addTransition(Delta, % delta()
            Parent_Last_Transition_State, % transition_from()
            Max_State_lastClause,  % max_State()
            unlabelled), % label()
          Max_State_lastClause+1, % last_Transition_State()
          Pre_assumedState, % pre_assumedState()
          [Max_State_lastClause+1|Transition_States]), % transition_States()

    % check if the last transition is only a unlabelled transition
    {Check_Delta, Check_Transition_States} =
      check_UnlabelRecv(unlabelled,
        lists:reverse(Clause_Delta),
        Pre_assumedState,
        NoRecursion,
        Clause_Last_Transition_State,
        Clause_Transition_States),

    % traverse over rest of the  clauses
    clause(Xs, % clauses()
      true, % many_clauses()
      true, % is_Nth_clause()
      MethodState_Map, % methodState_Map()
      lists:max(Check_Transition_States), % lastClause_max_State()
      lists:reverse(Check_Delta), % delta() : adding this clause delta to the rest.
      Parent_Last_Transition_State, % parent_Last_Transition_State()
      Pre_assumedState, % pre_assumedState()
      Check_Transition_States, % transition_States()
      noRecursion(NoRecursion, Length_Clauses)). % length_Clauses()



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec expressions(expressions(),  methodState_Map(), delta(), last_Transition_State(),
        pre_assumedState(), transition_States()) -> delta_Info().
    % expressions/6 takes the body of clause/ expressions(), methodState_Map(), delta() and some
    % other further information about the delta() and returns the delta_Info() for that given
    % expressions()




% when we have traversed to the end of the given expressions().
expressions([], _, Delta, Last_Transition_State, _, Transition_States) ->
    % delta_Info() :
    %  noRecursion == true because there was no recusrion since we have traversed to the very end
   {lists:reverse(Delta), Last_Transition_State, Transition_States, true};


%%%%% end of clause %%%%%


% when we encounter a send expression
expressions([{_,_,'!',Process_ID,Data}|Xs], MethodState_Map, Delta, Last_Transition_State,
  Last_Pre_assumedState, Transition_States) ->
    % get max transition state in the delta() so far.
    Max_State = lists:max(Transition_States),

    % adds the send transition the delta
    {Send_Delta, Send_Last_Transition_State} =
    add_SendTransition(Xs == [], % empty_Xs()
        Last_Pre_assumedState =/= -1, % exist_PreAssumedState()
        Last_Transition_State, % last_Transition_State()
        Last_Pre_assumedState, % pre_assumedState()
        Max_State, % max_State()
        Delta, % delta()
        {send, Process_ID, Data}), % label()

    expressions(Xs, % expressions()
      MethodState_Map, % methodState_Map()
      Send_Delta, % delta()
      Send_Last_Transition_State, % last_Transition_State()
      Last_Pre_assumedState, % pre_assumedState()
      [Max_State+1|Transition_States]); % transition_States() : also adding the new transition state


%%%%% end of clause %%%%%


% When there is a recursion i.e., we encounter a call expression
expressions([{call,_,{_,_,_}, _, Method_Term}|_], MethodState_Map, Delta, Last_Transition_State, _,
  Transition_States) ->
    % get this call expression method starting state
    RecursionToMethod_State = maps:get(Method_Term, MethodState_Map),
    case Delta == [] of
      % when there was no tranition inside this delta() before this call expression.
      true ->
        % delta_Info() :
        % -1 in place of last_transition_state() because there is no point of
        % last_transition_state() when a there is just recursion inside this
        % expressions().
        % false in place of noRecursion() because there is recursion
        {[], -1, Transition_States, false};

      % when there was transition before this call expression
      _ ->
        % change the last transition of the delta to recursionToMethod_State()
        changeTransitionsStates(Delta, % delta()
          Last_Transition_State, % last_Transition_State()
          [], % delta()
          RecursionToMethod_State, % recursionToMethod_State()
          Transition_States) % transition_States()
    end;


%%%%% end of clause %%%%%


% when we encounter a receive expression
expressions([{'receive', _, Body}|Xs], MethodState_Map, Delta, Last_Transition_State,
  Last_Pre_assumedState, Transition_States) ->
    Max_State = lists:max(Transition_States),
    % gets the pre_assumed state for this receive expressiom
    {Pre_assumedState, Pre_Transition_States, Pre_Max_State} =
      getPre_assumedState(Xs == [], % empty_Xs()
        Last_Pre_assumedState =/= -1, % exist_PreAssumedState()
        Last_Pre_assumedState, % pre_assumedState()
        Max_State+1, % the can be pre_assumedState()
        Transition_States), % transition_state()

    % get the new delta which also contain the delta for this receive expression and some further
    % information about it.
    {Recv_Delta, NoRecursion, Recv_Transition_States} =
        % we are passing "Max_State + 1" in place of last_receive_max_state() because
        % "Max_State + 1" might be the pre-assumed state for this recv expression
        receive_block(Body, % receive_clauses()
          Pre_assumedState, % pre_assumedState()
          Pre_Max_State, % last_receive_max_state()
          MethodState_Map, % methodState_Map()
          Delta, % delta()
          Last_Transition_State, % last_Transition_State()
          length(Body), % n_clauses()
          Pre_Transition_States), % transition_States()

    case NoRecursion == false of
     % when all the recv-clauses had recursion
     true ->
        % delta_Info()
        {lists:reverse(Recv_Delta), -1, Recv_Transition_States, false};

     % when not all of the recv-clauses had recursion
     _    ->
        % we are passing Pre_assumedState in place of last_Transition_State() because
        % Pre_assumedState is the last transition state of this receive expression.
        % And we are also adding pre-assumed state to the transition_States()
        expressions(Xs, % expressions()
          MethodState_Map, % methodState_Map()
          Recv_Delta, % delta()
          Pre_assumedState, % last_Transition_State()
          Last_Pre_assumedState, % pre_assumedState()
          Recv_Transition_States) % transition_States()
end;


%%%%% end of clause %%%%%


% when we encounter a function expression i.e., call to another function form inside
expressions([{function, Anno, Method_Name, Arity, Clauses, Method_Term}|Xs], MethodState_Map, Delta,
  Last_Transition_State,  Last_Pre_assumedState, Transition_States) ->
    Max_State = lists:max(Transition_States),
    % gets the pre_assumed state for this receive expressiom
    {Pre_assumedState, Pre_Transition_States, _} =
      getPre_assumedState(Xs == [], % empty_Xs()
        Last_Pre_assumedState =/= -1, % exist_PreAssumedState()
        Last_Pre_assumedState, % pre_assumedState()
        Max_State + 1, % the can be pre_assumedState()
        Transition_States), % transition_state()
     % calling the caa/5 to deal with this child method as a seprate method and
     % get its caa_Info()
    case caa({function, Anno, Method_Name, Arity, Clauses, Method_Term}, % method_Form()
           MethodState_Map, % methodState_Map()
           Last_Transition_State, % last_Transition_State()
           Pre_assumedState, % pre_assumedState()
           Pre_Transition_States, % transition_States()
           Delta) of % delta()

     % when there was no recursion inside this child method
     % i.e., noRecursion() == true
     {{_, Func_Delta}, Func_Last_Transition_State, Func_Recv_Transition_States, true} ->

        expressions(Xs, % expressions()
          MethodState_Map, % methodState_Map()
          lists:reverse(Func_Delta), % delta()
          Func_Last_Transition_State, % last_Transition_State()
          Last_Pre_assumedState, % pre_assumedState()
          Func_Recv_Transition_States); % transition_States()

     % when there is recursion
     % i.e., noRecursion() == false
     {{_, Func_Delta}, _, Func_Recv_Transition_States, false} ->
         % delta_Info()
         {Func_Delta, -1, Func_Recv_Transition_States, false}
    end;


%%%%% end of clause %%%%%


% when we encounter a case expression
expressions([{'case', _, _, Clauses}|Xs], MethodState_Map, Delta, Last_Transition_State,
  Last_Pre_assumedState, Transition_States) ->
    Max_State = lists:max(Transition_States),
    % gets the pre_assumed state for this receive expressiom
    {Pre_assumedState, Pre_Transition_States, _} =
      getPre_assumedState(Xs == [], % empty_Xs()
        Last_Pre_assumedState =/= -1, % exist_PreAssumedState()
        Last_Pre_assumedState, % pre_assumedState()
        Max_State + 1, % the can be pre_assumedState()
        Transition_States), % transition_state()

    % calling the clause/12 to deal with this case expression clauses as a seprately and
    % get its caa_Info().
    case clause(Clauses, % clauses()
      length(Clauses) > 1, % many_clauses()
      false, % is_Nth_clause()
      MethodState_Map, % methodState_Map()
      -1, % lastClause_max_State() : -1 because this is going to be the very first clause
      Delta, % delta()
      Last_Transition_State, % parent_Last_Transition_State()
      Pre_assumedState, % pre_assumedState()
      Pre_Transition_States, % transition_States()
      length(Clauses)) of % length_Clauses()

     % when not all the clauses had recursion
     % i.e., noRecusrion() == true
     {{_, Case_Delta}, Case_Last_Transition_States, Case_Recv_Transition_States, true} ->
        expressions(Xs, % expressions()
          MethodState_Map, % methodState_Map()
          lists:reverse(Case_Delta), % delt()
          Case_Last_Transition_States, % last_Transition_State()
          Last_Pre_assumedState, % pre_assumedState()
          Case_Recv_Transition_States);% transition_States()

     % when all the clauses had recursion
     % i.e., noRecursion() == false
     {{_, Case_Delta}, _, Case_Recv_Transition_States, false} ->
         % delta_info()
        {Case_Delta, -1, Case_Recv_Transition_States, false}
end;


%%%%% end of clause %%%%%


% when none of the above
expressions([_|Xs], MethodState_Map, Delta, Last_Transition_State, Last_Pre_assumedState,
  Transition_States) ->
    expressions(Xs, MethodState_Map, Delta, Last_Transition_State, Last_Pre_assumedState,
      Transition_States).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec receive_block(receive_clauses(), pre_assumedState(), last_receive_max_state(),
        methodState_Map(), delta(), last_Transition_State(), length_Clauses(),
        transition_States()) -> {delta(), noRecursion(), transition_States()}.
    % receive_block/8 takes receive_clauses() and delta() with some other information about them and
    % return a tuple which contain new delta() which also have the transition that are inside the
    % receive expression and some other  information about the new delta()


% base case
receive_block([], _, _, _, Delta, _, N_Clauses, Transition_States) ->
    {Delta, N_Clauses =/= 0, Transition_States};


%%%%% end of clause %%%%%


receive_block([{_, _, Recv, _, Body}|Xs], Pre_assumedState, LastRecvClause_Max_State,
  MethodState_Map, Delta, Last_Transition_State, N_Clauses, Transition_States) ->
    % adds this receive expression clause delta to the given delta() by calling the expresions/6
    % and passing the body of the receive-clause.
    {Recv_Delta, Recv_Last_Transition_States, Recv_Transition_States, NoRecursion} =
        % we are passing LastRecvClause_Max_State+1 in place of last_Transition_State() because
        % we are already adding the recv transition to the delta() and now its transition state is
        % the last state in the delta().
        expressions(Body, % expressions()
          MethodState_Map, % methodState_Map()
          %  delta() : adds the recv transition to the delta() prior
          addTransition(Delta, % delta()
            Last_Transition_State, % transition_from()
            LastRecvClause_Max_State, % max_State()
            {recv, Recv}), % label
          LastRecvClause_Max_State+1, % last_Transition_State()
          Pre_assumedState, % pre_assumedState()
          [LastRecvClause_Max_State+1|Transition_States]), % transition_States()


    {Check_Delta, Check_Transition_States} =
          check_UnlabelRecv(recv,
            lists:reverse(Recv_Delta),
            Pre_assumedState,
            NoRecursion,
            Recv_Last_Transition_States,
            Recv_Transition_States),

    % max state in the new delta
    Recv_Max_State = lists:max(Check_Transition_States),

    % trverse over other receive clauses.
    % we are passing Last_Transition_State in place of last_Transition_State() because we want the
    % next clause"recv" transtion start state to be Last_Transition_State.
    receive_block(Xs, % receive_clauses()
        Pre_assumedState, % pre_assumedState()
        Recv_Max_State, % last_receive_max_state()
        MethodState_Map, % methodState_Map()
        Check_Delta, % delta()
        Last_Transition_State, % last_Transition_State()
        noRecursion(NoRecursion, N_Clauses), % length_Clauses()
        Check_Transition_States). % transition_States()


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec addTransition(delta(), transition_from(), max_State(), type:label()) -> type:delta().
    % addTransition/4  adds transition via given transition_from(),
    % label() and max_State() to the given delta().

addTransition(Delta, Transition_from, Max_State, Label) ->
    [{Transition_from, Label, Max_State + 1}|Delta].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec changeTransitionsStates(delta(), last_Transition_State(), delta(),
        recursionToMethod_State(), transition_States()) -> delta_Info().
    % this changes the transtion's transition state which are last_Transition_State() in the delta()
    % to recursionToMethod_State()

% base case
changeTransitionsStates([], _, Delta, _, Transition_States) ->
    {Delta, -1, Transition_States, false};


%%%%% end of clause %%%%%


% when we encounter the transition whose transition state is last_Transition_State()
changeTransitionsStates([{First_State, Label, Last_Transition_State}|Xs], Last_Transition_State,
  Delta, RecursionToMethod_State, Transition_States) ->
    % in the delta() we're changing the transition state to RecursionToMethod_State.
    % And we're deleting it from the transition_States().
    changeTransitionsStates(Xs,  % delta()
      Last_Transition_State, % last_Transition_State()
      [{First_State, Label, RecursionToMethod_State}|Delta], % delta()
      RecursionToMethod_State, % recursionToMethod_State()
      lists:delete(Last_Transition_State, Transition_States)); % transition_States()


%%%%% end of clause %%%%%


% trnsition not having last_Transition_State() as thier transition state
changeTransitionsStates([{First_State, Label, Last_State}|Xs], Last_Transition_States, Delta,
  RecursionToMethod_State, Transition_States) ->
    changeTransitionsStates(Xs, % delta()
      Last_Transition_States, % last_Transition_State()
      [{First_State, Label, Last_State}|Delta], % delta()
      RecursionToMethod_State, % recursionToMethod_State()
      Transition_States). % transition_States()


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec noRecursion(noRecursion(), length_Clauses()) -> length_Clauses().
    % noRecursion/2 just reduce length_Clauses() by 1 if there is recursion otherwise it
    % won't do anything to length_Clauses().


% When there is recursion
noRecursion(false, Length) -> Length-1;


%%%%% end of clause %%%%%


% when there is no recurion
noRecursion(true, Length) -> Length.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec add_SendTransition(empty_Xs(), exist_PreAssumedState(), last_Transition_State(),
        pre_assumedState(), max_State(), delta(), type:label()) ->
          {delta(), last_Transition_State()}.
  % add_SendTransition/7 adds send transition to the delta() with appropriate transition
  % state and it return a tuple which contains the new delta and the its last transition state.


% when there is no expressions() after this send expression and Pre_assumedState is
% not equal to 1 that it's already been set by a parent method or a receive or a
% case expression.
% i.e., empty_Xs() == true and exist_PreAssumedState() == true
add_SendTransition(true, true, Last_Transition_State, Pre_assumedState, _, Delta, Label) ->
  % first element of the tuple delta() is  getting the send transition added to it, where
  % transition state is the pre-assumed state.
  {addTransition(Delta, % delta()
     Last_Transition_State, % transition_from()
     Pre_assumedState-1, % max_State()
     Label), % label()
    Pre_assumedState};


%%%%% end of clause %%%%%


% when the pre-assumed state is not set.
% i.e, exist_PreAssumedState() == false
add_SendTransition(_, _, Last_Transition_State, _, Max_State, Delta, Label) ->
  % first element of the tuple delta() is getting the send transition added to it, where
  % transition state is Max_State+1.
  {addTransition(Delta, % delta()
    Last_Transition_State, % transition_from()
    Max_State, % max_State()
    Label),% label()
   Max_State+1}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


-spec getPre_assumedState(empty_Xs(), exist_PreAssumedState(), pre_assumedState(),
        pre_assumedState(), transition_States()) ->
          {pre_assumedState(), transition_States(), max_State()}.
    % getPre_assumedState/4 tells what pre_assumedState we should use for the current
    % function, receive or case expression.


% when expression() is [] after this current expression and pre_assumedState() is already set,
% we just return the already set Last_Pre_assumedState
% i.e., empty_Xs()  and  exist_PreAssumedState() equal to true
getPre_assumedState(true, true, Last_Pre_assumedState, _, Transition_States) ->
  {Last_Pre_assumedState, Transition_States, lists:max(Transition_States)};


%%%%% end of clause %%%%%


% when pre_assumedState() not set i.e., -1, but the max state + 1 is to
% be equal to Last_Pre_assumedState
% example: file "testing_files/function.erl" function "f/2"
getPre_assumedState(_, _, Last_Pre_assumedState, Last_Pre_assumedState, Transition_States) ->
  Pre_State = Last_Pre_assumedState + 1,
  Pre_Transition = [Pre_State| Transition_States],
  {Last_Pre_assumedState + 1, Pre_Transition, Pre_State};


%%%%% end of clause %%%%%


% when pre_assumedState() not set i.e., -1, we then just calculate a
% new Pre_assumedState
getPre_assumedState(_, _, _, Pre_assumedState, Transition_States) ->
  {Pre_assumedState, [Pre_assumedState|Transition_States], Pre_assumedState}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-spec check_UnlabelRecv(atom(), delta(), pre_assumedState(), noRecursion(), last_Transition_State(),
        transition_States()) -> {delta(), transition_States()}.
    % check_UnlabelRecv/4 changes the transition state of recv or unlabelled transition to
    % pre-assumed state, if they are the last transition of a particular clause

% when the last transition is a recv transiton.
% we change its transition state to Pre_assumedState
check_UnlabelRecv(recv, [{Start_State, {recv, Data}, _}|Xs], Pre_assumedState, true, _,
  Transition_States) ->
  {[{Start_State, {recv, Data}, Pre_assumedState}|Xs], Transition_States};


%%%%% end of clause %%%%%


% when the last transition is a unlabelled transiton.
% we change its transition state to Pre_assumedState
check_UnlabelRecv(unlabelled, [{Start_State, unlabelled, _}|Xs], Pre_assumedState, true, _,
  Transition_States) ->
    {[{Start_State, unlabelled, Pre_assumedState}|Xs], Transition_States};


%%%%% end of clause %%%%%

% none of the above that means we don't need to change any transition state
check_UnlabelRecv(_, Delta, _, _, _, Transition_States) ->
  {Delta, Transition_States}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%